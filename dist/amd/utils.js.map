{"version":3,"sources":["../../src/utils.js"],"names":[],"mappings":"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","file":"utils.js","sourcesContent":["import angular from 'angular';\n\n// Static object members need to be overridden async since some keys\n// need to be resolved AFTER the class has fully been defined. This is\n// because some property decorators might rely on class decorator configs,\n// and property decorators are called before class decorators.\nexport function addStaticGetterObjectMember(cls, propertyName, key, value, override = true) {\n  const currentPropertyDescriptor = Reflect.getOwnPropertyDescriptor(cls, propertyName);\n  Reflect.defineProperty(cls, propertyName, {\n    configurable: true,\n    get: () => {\n      const newObject = getCurrentDescriptorValue(currentPropertyDescriptor);\n      const resolvedKey = angular.isFunction(key) ? key() : key;\n      if (override === true || !angular.isDefined(newObject[resolvedKey])) {\n        newObject[resolvedKey] = value;\n      }\n      return newObject;\n    }\n  });\n}\n\nexport function mergeStaticGetterObject(cls, propertyName, values, override = true) {\n  // Look at the explanation above addStaticGetterObjectMember to see\n  // why we do this override asynchronously...\n  const currentPropertyDescriptor = Reflect.getOwnPropertyDescriptor(cls, propertyName);\n  Reflect.defineProperty(cls, propertyName, {\n    configurable: true,\n    get: () => {\n      return override\n        ? Object.assign({}, getCurrentDescriptorValue(currentPropertyDescriptor), values)\n        : Object.assign({}, values, getCurrentDescriptorValue(currentPropertyDescriptor));\n    }\n  });\n}\n\nexport function addStaticGetterArrayMember(cls, propertyName, value) {\n  mergeStaticGetterArray(cls, propertyName, [value]);\n}\n\nexport function mergeStaticGetterArray(cls, propertyName, values) {\n  const getterArray = cls[propertyName] || [];\n  for (const value of values) {\n    if (getterArray.indexOf(value) === -1) {\n      getterArray.push(value);\n    }\n  }\n  Reflect.defineProperty(cls, propertyName, {\n    configurable: true,\n    get: () => getterArray\n  });\n}\n\nexport function addStaticGetter(cls, property, getter) {\n  Reflect.defineProperty(cls, property, {configurable: true, get: getter});\n}\n\nexport function addBehavior(cls, BehaviorCls, {property, config, proxy}) {\n  const internalProperty = `_${property}`;\n  Reflect.defineProperty(cls.prototype, property, {\n    get() {\n      if (!this[internalProperty]) {\n        this[internalProperty] = new BehaviorCls(this, config);\n      }\n      return this[internalProperty];\n    }\n  });\n\n  if (proxy) {\n    addProxies(cls, BehaviorCls, property, proxy);\n  }\n\n  // We store the behavior property somewhere on the class so that we can\n  // instantiate all the behaviors in the constructor of the class\n  addStaticGetterArrayMember(cls, 'behaviors', property);\n}\n\nexport function addProxies(cls, BehaviorCls, property, proxies) {\n  for (const proxy of proxies) {\n    const parts = proxy.split(':');\n    const localName = parts[0].trim();\n\n    // We don't want to override any methods that already exist in the prototype\n    // of the target cls. If the method already exists, its the class author's\n    // responsibility to call behavior methods.\n    /*eslint-disable no-loop-func */\n    if (!Reflect.getOwnPropertyDescriptor(cls.prototype, localName)) {\n      const externalName = parts[1] ? parts[1].trim() : localName;\n      const descriptor = Reflect.getOwnPropertyDescriptor(BehaviorCls.prototype, externalName);\n\n      // This should be a simple property\n      if (angular.isUndefined(descriptor) || angular.isDefined(descriptor.get)) {\n        const proxyDescriptor = {\n          get() {\n            return this[property][externalName];\n          }\n        };\n\n        if (angular.isDefined(descriptor) && angular.isDefined(descriptor.set)) {\n          Object.assign(proxyDescriptor, {\n            set(value) {\n              this[property][externalName] = value;\n            }\n          });\n        }\n\n        Reflect.defineProperty(cls.prototype, localName, proxyDescriptor);\n      } else if (angular.isDefined(descriptor.value)) {\n        Reflect.defineProperty(cls.prototype, localName, {\n          value() {\n            return this[property][externalName](...arguments);\n          }\n        });\n      }\n\n      /*eslint-enable no-loop-func */\n    }\n  }\n}\n\nexport function Inject(injectionName) {\n  return (cls, propertyName) => {\n    let preparedInjectionName = injectionName;\n    if (!preparedInjectionName) {\n      preparedInjectionName = `${propertyName[0].toUpperCase()}${propertyName.slice(1)}`;\n    }\n    addStaticGetterObjectMember(cls.constructor, 'injections',\n      propertyName, preparedInjectionName);\n  };\n}\n\nexport function Decorators(decorators) {\n  return cls => {\n    for (const decorator of decorators) {\n      addStaticGetterArrayMember(cls, 'decorators', decorator);\n    }\n  };\n}\n\nexport function getCurrentDescriptorValue(propertyDescriptor) {\n  if (propertyDescriptor === undefined) {\n    return {};\n  } else if (propertyDescriptor.get) {\n    return propertyDescriptor.get();\n  }\n  return propertyDescriptor.value;\n}\n\nexport function camelcase(name) {\n  return `${name[0].toUpperCase()}${name.slice(1)}`;\n}\n\nexport function camelCaseToDashes (name) {\n  return name.replace(/([a-z])([A-Z])/g, '$1-$2');\n}\n\nexport function dashesToCamelCase (name) {\n  return String(name).replace(/-([a-z])/g, part => part[1].toUpperCase());\n}\n"]}